SELECT SYSDATE FROM DUAL; -- DUAL 가상 테이블

SELECT SYSDATE-30, SYSDATE, SYSDATE+30 FROM DUAL;

-- EMPLOYEES 테이블 HIRE_DATE 컬럼
SELECT HIRE_DATE-1,HIRE_DATE,HIRE_DATE+1 FROM EMPLOYEES;

-- 날짜 범위 검색가능, 정렬 ORDER BY, ASC/DESC 
SELECT EMP_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE >= '02-01-01' AND HIRE_DATE <= '04-12-31'
ORDER BY HIRE_DATE DESC;

SELECT EMP_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE BETWEEN '02-01-01' AND '04-12-31' ORDER BY HIRE_DATE;

SELECT EMP_NAME FROM EMPLOYEES WHERE EMP_NAME LIKE '___a%';

SELECT EMP_NAME FROM EMPLOYEES WHERE EMP_NAME LIKE '%e_';

-- 정렬 DESC : NULL ASC : 제일 아래
SELECT DEPARTMENT_ID FROM EMPLOYEES ORDER BY DEPARTMENT_ID DESC;

-- 월급(SALARY) 역순정렬
SELECT EMP_NAME, SALARY FROM EMPLOYEES ORDER BY SALARY DESC;

-- STUDENTS 테이블에서 TOTAL 역순정렬
SELECT NO,NAME,TOTAL FROM STUDENTS ORDER BY TOTAL DESC;

-- HIRE_DATE 기준 순차정렬
SELECT EMP_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE;

SELECT NAME,KOR,ENG,MATH FROM STUDENTS ORDER BY KOR DESC ,ENG DESC;

-- 한국어도 순차정렬 ㄱㄴㄷ..
SELECT NAME FROM STUDENTS ORDER BY NAME DESC;

-- 입사일이 빠른 순으로 정렬하는데 이름은 역순으로 정렬하시오.
SELECT EMP_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE , EMP_NAME DESC;

-- ABS 절대값
SELECT -10 VAL ,ABS(-10) AS ABS FROM DUAL;

SELECT KOR,KOR-ENG,ABS(KOR-ENG) ABS FROM STUDENTS ORDER BY ABS DESC;

-- FLOOR ; 소수점 이하 버림
SELECT 3.141592, FLOOR(3.141592) FROM DUAL;
-- TRUNC ; 버림, 자리수 지정
SELECT 3.141592, TRUNC(3.141592,2) FROM DUAL;

-- CEIL ; 소수점 이하 올림
SELECT 3.141592, CEIL(3.141592) FROM DUAL;

-- ROUND ; 반올림, 자리수 범위 지정
SELECT 34.5678, ROUND(34.5678) FROM DUAL;
SELECT 34.5678, ROUND(34.5678,2) FROM DUAL;

-- 양수 첫째자리에서 반올림, 소수점 자리수에서 앞쪽으로 한칸위치 반올림
SELECT 34.5678, ROUND(34.5678 ,-1) FROM DUAL;

-- MOD ; 나머지
SELECT 27/2 , MOD(27,2) FROM DUAL;
SELECT 30/3, MOD(31,7) FROM DUAL;

-- 사원번호가 홀수 인 사원을 출력하시오.
SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE MOD(EMPLOYEE_ID,2) = 1;

-- 최종연봉 ; 월급*12+(월급*12)*커미션 소수점 2자리에서 반올림 첫째자리로 만드시오.
SELECT SALARY 월급,ROUND(salary*12+((salary*12)*(nvl(commission_pct,0)*0.01))*1381.86795,2) YSALARY FROM EMPLOYEES;

SELECT * FROM STUDENTS;


-- 시퀀스 ; 자동으로 번호부여
CREATE SEQUENCE STU_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;

-- 시퀀스에서 번호 생성
SELECT STU_SEQ.NEXTVAL FROM DUAL;
SELECT STU_SEQ.CURRVAL FROM DUAL;

-- 게시판 테이블 생성
CREATE TABLE BOARD(
BNO NUMBER(4),
BTITLE VARCHAR2(100),
BCONTENT VARCHAR2(4000),
ID VARCHAR2(30),
BHIT NUMBER(10),
BDATE DATE
);

INSERT INTO BOARD VALUES(
2, '제목입니다.2','내용입니다.2','aaa',1,SYSDATE
);

INSERT INTO BOARD VALUES(
stu_seq.nextval, '제목입니다.2','내용입니다.2','aaa',1,SYSDATE
);

SELECT * FROM BOARD;

CREATE SEQUENCE BOARD_SEQ
START WITH 14 -- 시작번호
INCREMENT BY 1 -- 증감숫자
MINVALUE 1 -- 최소값
MAXVALUE 9999 -- 최대값
NOCYCLE -- 1-9999 이상이 되면 다시 1
NOCACHE -- 메모리에 시퀀스값 미리할당
;

INSERT INTO BOARD VALUES(
BOARD_SEQ.NEXTVAL,'제목14','내용14','aaa',1,SYSDATE
);
SELECT * FROM BOARD;

UPDATE BOARD SET BTITLE = '제목을다시변경' WHERE BNO=14;

--DROP TABLE BOARD;
CREATE TABLE BOARD(
BNO NUMBER(4),
BTITLE VARCHAR2(100),
BCONTENT CLOB, -- VARCHAR2 무제한버전 대용량 글자타입
ID VARCHAR2(20),
BGROUP NUMBER(4), -- 답변달기 그룹핑
BSTEP NUMBER(4), -- 답변달기 경우 순서정의
BINDENT NUMBER(4), -- 답변달기 들여쓰기
BHIT NUMBER(10), -- 조회수
BDATE DATE -- 등록일
);

INSERT INTO BOARD VALUES(
BOARD_SEQ.NEXTVAL,CONCAT('제목',BOARD_SEQ.CURRVAL),'내용1','aaa',BOARD_SEQ.CURRVAL,0,0,1,SYSDATE
);

SELECT * FROM BOARD;

-- 시퀀스 생성
-- STUDENTS_SEQ.NEXTVAL
-- STUDENTS 테이블 100 -> 101
-- 101 '홍길순' 100 99 90 TOTAL AVG RANK 날짜
-- 1명 입력
INSERT INTO STUDENTS VALUES(
STUDENTS_SEQ.NEXTVAL,'홍길순',99,99,90,(99+99+90),(99+99+90)/3,0,SYSDATE
);
SELECT * FROM STUDENTS;

SELECT S.*,ROUND(AVG,2) FROM STUDENTS S;


SELECT DEPT_SEQ.NEXTVAL FROM DUAL;

-- S_SEQ
-- 1 1 9999

-- 시퀀스 생성, NEXTVAL; 다음 시퀀스번호 생성 CURRVAL; 현재시퀀스 번호 보여줌
SELECT S_SEQ.NEXTVAL FROM DUAL;
SELECT EMP_SEQ.NEXTVAL FROM DUAL;
SELECT EMP_SEQ.CURRVAL FROM DUAL;


-- 타입
-- 문자형 숫자형 날짜형
-- CHAR VARCHAR2 / NCHAR NVARCAHR2 / LONG CLOB
-- CHAR & VARCHAR2 ; 한글문자 입력시 3바이트 사용
-- VARCHAR2(6) ; 한글 2글자 입력
-- NVARCHAR2(5) ; 한글 5자리까지 입력가능 - 2BYTE
-- NUMBER
-- DATE-초까지 입력 / TIMESTAMP-밀리세컨드까지 입력


SELECT '홍길동' FROM DUAL;
-- LENGTH ; 문자길이
SELECT LENGTH('홍길동') FROM DUAL;

-- 이름의 길이로 역순정렬
SELECT NAME, LENGTH(NAME) N FROM STUDENTS ORDER BY N DESC;

-- LENGTHB ; BYTE 크기
SELECT LENGTHB('홍길동') FROM DUAL;


SELECT * FROM STUDENTS;

-- 합계가 200점 이상이면서 번호가 10번 이상 50번 이하이면서 이름의 2번째 자리에 e가 들어가 있는 학생을 출력하시오.
SELECT * FROM STUDENTS WHERE TOTAL >= 200 AND NO >= 10 AND NO <= 50 AND NAME LIKE '_e%';

SELECT * FROM STUDENTS WHERE TOTAL>=200;

-- 2중 쿼리
SELECT * FROM (SELECT * FROM STUDENTS WHERE TOTAL>=200)WHERE NAME LIKE '_e%' AND NO >= 30;

SELECT * FROM STUDENTS;

SELECT NO,NAME,TOTAL,RANK FROM STUDENTS;

-- 등수함수 ; RANK()OVER(기준점)입력 , NO 중복이 없음 ; 유일키 기본키 프라이머리키(PRIMARY KEY)
SELECT NO, RANK()OVER(ORDER BY TOTAL DESC)RANKS FROM STUDENTS;
SELECT RANKS FROM (SELECT NO, RANK()OVER(ORDER BY TOTAL DESC)RANKS FROM STUDENTS);

-- 수정 ; UPDATE 등수 설정..
UPDATE STUDENTS A 
SET RANK = (SELECT RANKS FROM (SELECT NO, RANK()OVER(ORDER BY TOTAL DESC) RANKS FROM STUDENTS)B
WHERE A.NO = B.NO);

UPDATE STUDENTS A SET RANK =1 WHERE A.NO = 101;

SELECT NO,NAME,TOTAL,RANK FROM STUDENTS ORDER BY TOTAL DESC;

SELECT * FROM STUDENTS ORDER BY RANK;

SELECT NO, RANK()OVER(ORDER BY TOTAL DESC) R FROM STUDENTS;

UPDATE STUDENTS SET RANK = 1 WHERE NO = 101;
UPDATE STUDENTS SET RANK = 2 WHERE NO = 96;
UPDATE STUDENTS SET RANK = 3 WHERE NO = 64;
UPDATE STUDENTS SET RANK = 4 WHERE NO = 49;
UPDATE STUDENTS SET RANK = 5 WHERE NO = 14;
SELECT NO, TOTAL RANK FROM STUDENTS ORDER BY TOTAL DESC;

-- 사원번호가 높은 순으로 등수를 생성하시오.
SELECT * FROM EMPLOYEES;
SELECT RANK()OVER(ORDER BY EMPLOYEE_ID DESC), EMPLOYEE_ID, EMP_NAME FROM EMPLOYEES ORDER BY EMPLOYEE_ID DESC;

-- EMP2 테이블 복사, EMPLOYEES 테이블
CREATE TABLE EMP2 AS SELECT * FROM EMPLOYEES;

SELECT RANK()OVER(ORDER BY EMPLOYEE_ID DESC) FROM EMPLOYEES;

-- RANK 테이블 컬럼 추가
ALTER TABLE EMP2 ADD RANK NUMBER(4);

-- RANK() 등수를 RANK에 입력
UPDATE EMP2 E SET RANK = (
SELECT RANKS FROM (SELECT EMPLOYEE_ID,RANK()OVER(ORDER BY EMPLOYEE_ID DESC)RANKS FROM EMPLOYEES)E2
WHERE E.EMPLOYEE_ID = E2.EMPLOYEE_ID
);

SELECT * FROM EMP2 ORDER BY RANK DESC;

SELECT * FROM EMP2;

--컬럼의 순서를 변경
--EMP_NAME 뒤에 RANK컬럼을 배치
ALTER TABLE EMP2 MODIFY EMAIL VISIBLE;
ALTER TABLE EMP2 MODIFY PHONE_NUMBER VISIBLE;
ALTER TABLE EMP2 MODIFY HIRE_DATE VISIBLE;
ALTER TABLE EMP2 MODIFY SALARY VISIBLE;
ALTER TABLE EMP2 MODIFY MANAGER_ID VISIBLE;
ALTER TABLE EMP2 MODIFY COMMISSION_PCT VISIBLE;
ALTER TABLE EMP2 MODIFY RETIRE_DATE VISIBLE;
ALTER TABLE EMP2 MODIFY DEPARTMENT_ID VISIBLE;
ALTER TABLE EMP2 MODIFY JOB_ID VISIBLE;
ALTER TABLE EMP2 MODIFY CREATE_DATE VISIBLE;
ALTER TABLE EMP2 MODIFY UPDATE_DATE VISIBLE;
DESC EMP2;

SELECT * FROM EMP2;

SELECT * FROM DEPARTMENTS;
-- 부서명 입력
UPDATE EMP2 E SET E.DEPARTMENT_NAME = (
SELECT D FROM (SELECT DEPARTMENT_ID,DEPARTMENT_NAME FROM DEPARTMENTS)E2
WHERE E.DEPARTMENT_ID = E2.DEPARTMENT_ID
);

SELECT DEPARTMENT_ID, DEPARTMENT_NAME FROM EMP2;

-- 테이블 복사
CREATE TABLE STU AS SELECT * FROM STUDENTS;

DESC STU;
--ALTER TABLE STU DROP COLUMN RANK; 


SELECT * FROM STU;

-- TOTAL 컬럼 AVG 컬럼 추가
ALTER TABLE STU ADD TOTAL NUMBER(3);
ALTER TABLE STU ADD AVG NUMBER(4,2);
ALTER TABLE STU ADD RANK NUMBER(3);
ALTER TABLE STU MODIFY SDATE VISIBLE;

UPDATE STU SET TOTAL = KOR+ENG+MATH, AVG=(KOR+ENG+MATH)/3;

-- RANK 입력
SELECT * FROM STU;

UPDATE STU S SET RANK = (SELECT RANK FROM (SELECT NO,RANK()OVER(ORDER BY TOTAL DESC)RANK FROM STU)S2
WHERE S.NO = S2.NO);


---- 날짜 함수 
---- 현재 날짜 ; SYSDATE
SELECT SYSDATE FROM DUAL;

CREATE TABLE DATETABLE(
NO NUMBER(4),
PREDATE DATE,
TODAY DATE,
NEXTDATE DATE
);

INSERT INTO DATETABLE VALUES(1,SYSDATE-30,SYSDATE,SYSDATE+180);

SELECT * FROM DATETABLE;

SELECT NO,PREDATE,TODAY 가입일,NEXTDATE 만료일 FROM DATETABLE;

SELECT ID,NAME,MDATE FROM MEMBER WHERE SYSDATE>= MDATE+180;

-- 입사일 현재날짜와 입사일 몇일 지났는지 출력하시오.
-- EMPLOYEES HIRE DATE
--15일 이상이면 1달을 올림
SELECT HIRE_DATE,ROUND(HIRE_DATE,'MONTH'), ROUND(SYSDATE-HIRE_DATE) FROM EMPLOYEES;

SELECT HIRE_DATE,TRUNC(HIRE_DATE,'MONTH') FROM EMPLOYEES;

-- 입사일 현재일 기준의 달수
SELECT HIRE_DATE,SYSDATE,MONTHS_BETWEEN(SYSDATE,HIRE_DATE) FROM EMPLOYEES;

SELECT HIRE_DATE,SYSDATE,ROUND(MONTHS_BETWEEN(SYSDATE,HIRE_DATE))달수,ROUND(SYSDATE-HIRE_DATE)일자 FROM EMPLOYEES;

SELECT HIRE_DATE,ADD_MONTHS(HIRE_DATE,3) FROM EMPLOYEES;

SELECT SYSDATE,NEXT_DAY(SYSDATE,'수요일') FROM DUAL;

SELECT SYSDATE, NEXT_DAY(SYSDATE,'토요일') FROM DUAL;

-- LAST_DATE ; 그 달의 마지막 날짜를 알려줌
SELECT LAST_DAY(SYSDATE) FROM DUAL;

SELECT SYSDATE, LAST_DAY(SYSDATE) FROM DUAL;

SELECT SYSDATE FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY-MM-DD HH24:MI:SS') FROM DUAL;

select * from member where id = 'eee';

SELECT TO_CHAR(HIRE_DATE,'YYYY-MM-DD') FROM EMPLOYEES;

select * from member where id = 'aaa'and pw= '1111';

